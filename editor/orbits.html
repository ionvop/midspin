<html>
    <head>
        <title>
            Editor
        </title>
        <style>
            body {
                margin: 0rem;
            }

            textarea {
                font-size: 1.5rem;
                width: 100%;
                height: 4rem;
                padding: 1rem;
                resize: none;
            }

            .main .page > .content {
                padding: 5rem;
                font-size: 1.5rem;
            }

            .main .container > .details {
                font-size: 1.5rem;
                line-height: 150%;
                font-family: 'Courier New', Courier, monospace;
                font-weight: bold;
            }

            .main .content > .container {
                display: grid;
                grid-template-columns: 30% auto;
            }

            .main .container > textarea[name="script"] {
                height: 23rem;
            }

            .main .content > textarea[name="result"] {
                margin-top: 3rem;
            }
        </style>
    </head>
    <body>
        <div class="main">
            <div class="page">
                <div class="content">
                    <div class="container">
                        <div class="details">
                            BPM = 120<br>
                            Current time = 0
                        </div>
                        <textarea name="script" onkeyup="Compile()" onpointerup="Compile()"></textarea>
                    </div>
                    <textarea name="result"></textarea>
                </div>
            </div>
        </div>
    </body>
    <script>
        class Tween {
            multiplierToNormalNumber(mul, start, end) {
                const multiplier = end - start;
                const result = (mul * multiplier) + start;
                return result;
            }

            // blocks
            tweenValue(easeMethod, easeDirection, start, end, progress) {
                let EasingMethods = [
                    "linear",
                    "sine",
                    "quad",
                    "cubic",
                    "quart",
                    "quint",
                    "expo",
                    "circ",
                    "back",
                    "elastic",
                    "bounce"
                ];

                // easing method does not exist, return starting number
                if (!EasingMethods.includes(easeMethod)) return start;
                // easing method is not implemented, return starting number
                if (!this[easeMethod]) return start;

                const tweened = this[easeMethod](progress, easeDirection);
                return this.multiplierToNormalNumber(tweened, start, end);
            }

            // easing functions (placed below blocks for organization)
            linear(x) {
                // lol
                return x;
            }

            sine(x, dir) {
                switch (dir) {
                    case "in": {
                        return 1 - Math.cos((x * Math.PI) / 2);
                    }
                    case "out": {
                        return Math.sin((x * Math.PI) / 2);
                    }
                    case "in out": {
                        return -(Math.cos(Math.PI * x) - 1) / 2;
                    }
                    default:
                        return 0;
                }
            }

            quad(x, dir) {
                switch (dir) {
                    case "in": {
                        return x * x;
                    }
                    case "out": {
                        return 1 - (1 - x) * (1 - x);
                    }
                    case "in out": {
                        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
                    }
                    default:
                        return 0;
                }
            }

            cubic(x, dir) {
                switch (dir) {
                    case "in": {
                        return x * x * x;
                    }
                    case "out": {
                        return 1 - Math.pow(1 - x, 3);
                    }
                    case "in out": {
                        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
                    }
                    default:
                        return 0;
                }
            }

            quart(x, dir) {
                switch (dir) {
                    case "in": {
                        return x * x * x * x;
                    }
                    case "out": {
                        return 1 - Math.pow(1 - x, 4);
                    }
                    case "in out": {
                        return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;
                    }
                    default:
                        return 0;
                }
            }

            quint(x, dir) {
                switch (dir) {
                    case "in": {
                        return x * x * x * x * x;
                    }
                    case "out": {
                        return 1 - Math.pow(1 - x, 5);
                    }
                    case "in out": {
                        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
                    }
                    default:
                        return 0;
                }
            }

            expo(x, dir) {
                switch (dir) {
                    case "in": {
                        return x === 0 ? 0 : Math.pow(2, 10 * x - 10);
                    }
                    case "out": {
                        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
                    }
                    case "in out": {
                        return x === 0
                            ? 0
                            : x === 1
                                ? 1
                                : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2
                                    : (2 - Math.pow(2, -20 * x + 10)) / 2;
                    }
                    default:
                        return 0;
                }
            }

            circ(x, dir) {
                switch (dir) {
                    case "in": {
                        return 1 - Math.sqrt(1 - Math.pow(x, 2));
                    }
                    case "out": {
                        return Math.sqrt(1 - Math.pow(x - 1, 2));
                    }
                    case "in out": {
                        return x < 0.5
                            ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2
                            : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;
                    }
                    default:
                        return 0;
                }
            }

            back(x, dir) {
                switch (dir) {
                    case "in": {
                        const c1 = 1.70158;
                        const c3 = c1 + 1;

                        return c3 * x * x * x - c1 * x * x;
                    }
                    case "out": {
                        const c1 = 1.70158;
                        const c3 = c1 + 1;

                        return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
                    }
                    case "in out": {
                        const c1 = 1.70158;
                        const c2 = c1 * 1.525;

                        return x < 0.5
                            ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
                            : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
                    }
                    default:
                        return 0;
                }
            }

            elastic(x, dir) {
                switch (dir) {
                    case "in": {
                        const c4 = (2 * Math.PI) / 3;

                        return x === 0
                            ? 0
                            : x === 1
                                ? 1
                                : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);
                    }
                    case "out": {
                        const c4 = (2 * Math.PI) / 3;

                        return x === 0
                            ? 0
                            : x === 1
                                ? 1
                                : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
                    }
                    case "in out": {
                        const c5 = (2 * Math.PI) / 4.5;

                        return x === 0
                            ? 0
                            : x === 1
                                ? 1
                                : x < 0.5
                                    ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2
                                    : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1;
                    }
                    default:
                        return 0;
                }
            }

            bounce(x, dir) {
                switch (dir) {
                    case "in": {
                        return 1 - this.bounce(1 - x, "out");
                    }
                    case "out": {
                        const n1 = 7.5625;
                        const d1 = 2.75;

                        if (x < 1 / d1) {
                            return n1 * x * x;
                        } else if (x < 2 / d1) {
                            return n1 * (x -= 1.5 / d1) * x + 0.75;
                        } else if (x < 2.5 / d1) {
                            return n1 * (x -= 2.25 / d1) * x + 0.9375;
                        } else {
                            return n1 * (x -= 2.625 / d1) * x + 0.984375;
                        }
                    }
                    case "in out": {
                        return x < 0.5
                            ? (1 - this.bounce(1 - 2 * x, "out")) / 2
                            : (1 + this.bounce(2 * x - 1, "out")) / 2;
                    }
                    default:
                        return 0;
                }
            }
        }

        function Compile() {
            let fumen = [];
            let bpm = 120;
            let interval = 2000;
            let offset = 0;
            let time = 0;
            let result = "";
            let orbits = {};
            let orbitNumber = 1;
            let timeline = {};
            let b = SetBpm;
            let o = SetOffset;
            let t = Transpose;
            let p = SetPosition;
            let g = GetMeasure;
            let m = Move;
            let r = Rotate;
            let s = Scale;
            let d = Distance;
            let x = SetOrbitNumber;
            let tween = new Tween();

            function OverwriteOrbit(orbit) {
                if (orbits[orbit] == undefined) {
                    orbits[orbit] = [
                        0,
                        0,
                        0,
                        50,
                        50
                    ]
                }
            }

            function OverwriteTimeline(time, orbit) {
                time /= 20;
                time = Math.floor(time);
                time *= 20;

                timeline[time + "/" + orbit] = [time, orbit, orbits[orbit][0], orbits[orbit][1], orbits[orbit][2], orbits[orbit][3], orbits[orbit][4]];
            }

            function GetTimeline(time, orbit) {
                time /= 20;
                time = Math.floor(time);
                time *= 20;
                time += "/" + orbit;

                if (timeline[time] == undefined) {
                    return false;
                }

                return [timeline[time][2], timeline[time][3], timeline[time][4], timeline[time][5], timeline[time][6]];
            }

            function SetOrbitNumber(input) {
                orbitNumber = input;
            }

            function SetBpm(input) {
                bpm = input;
                interval = (240 / bpm) * 1000;
            }

            function SetOffset(input) {
                offset = input;
                time = input;
            }

            function Transpose(input) {
                time += input;
            }

            function SetPosition(settime = time) {
                time = settime;
            }

            function GetMeasure(measure) {
                return interval / measure;
            }

            function Move(orbit, length, startX, startY, endX, endY, ease = 1) {
                let direction = "in";
                OverwriteOrbit(orbit);

                switch (ease) {
                    case 1:
                        ease = "linear";
                        break;
                    case 2:
                        ease = "sine";
                        break;
                    case 3:
                        ease = "sine";
                        direction = "out";
                        break;
                    case 4:
                        ease = "sine";
                        direction = "in out";
                        break;
                }

                for (let currentTime = time; currentTime < time + length; currentTime = currentTime + 20) {
                    if (GetTimeline(currentTime, orbit) != false) {
                        orbits[orbit] = GetTimeline(currentTime, orbit);
                    }

                    orbits[orbit][0] = tween.tweenValue(ease, direction, startX, endX, (currentTime - time) / length);
                    orbits[orbit][1] = tween.tweenValue(ease, direction, startY, endY, (currentTime - time) / length);
                    OverwriteTimeline(currentTime, orbit);
                }

                if (GetTimeline(time + length, orbit) != false) {
                    orbits[orbit] = GetTimeline(time + length, orbit);
                }

                orbits[orbit][0] = endX;
                orbits[orbit][1] = endY;
                OverwriteTimeline(time + length, orbit);
            }

            function Rotate(orbit, length, startAngle, endAngle, ease = 1) {
                let direction = "in";
                OverwriteOrbit(orbit);

                switch (ease) {
                    case 1:
                        ease = "linear";
                        break;
                    case 2:
                        ease = "sine";
                        break;
                    case 3:
                        ease = "sine";
                        direction = "out";
                        break;
                    case 4:
                        ease = "sine";
                        direction = "in out";
                        break;
                }

                for (let currentTime = time; currentTime < time + length; currentTime = currentTime + 20) {
                    if (GetTimeline(currentTime, orbit) != false) {
                        orbits[orbit] = GetTimeline(currentTime, orbit);
                    }

                    orbits[orbit][2] = tween.tweenValue(ease, direction, startAngle, endAngle, (currentTime - time) / length);
                    OverwriteTimeline(currentTime, orbit);
                }

                if (GetTimeline(time + length, orbit) != false) {
                    orbits[orbit] = GetTimeline(time + length, orbit);
                }

                orbits[orbit][2] = endAngle;
                OverwriteTimeline(time + length, orbit);
            }

            function Scale(orbit, length, startSize, endSize, ease = 1) {
                let direction = "in";
                OverwriteOrbit(orbit);

                switch (ease) {
                    case 1:
                        ease = "linear";
                        break;
                    case 2:
                        ease = "sine";
                        break;
                    case 3:
                        ease = "sine";
                        direction = "out";
                        break;
                    case 4:
                        ease = "sine";
                        direction = "in out";
                        break;
                }

                for (let currentTime = time; currentTime < time + length; currentTime = currentTime + 20) {
                    if (GetTimeline(currentTime, orbit) != false) {
                        orbits[orbit] = GetTimeline(currentTime, orbit);
                    }

                    orbits[orbit][3] = tween.tweenValue(ease, direction, startSize, endSize, (currentTime - time) / length);
                    OverwriteTimeline(currentTime, orbit);
                }

                if (GetTimeline(time + length, orbit) != false) {
                    orbits[orbit] = GetTimeline(time + length, orbit);
                }

                orbits[orbit][3] = endSize;
                OverwriteTimeline(time + length, orbit);
            }

            function Distance(orbit, length, startDistance, endDistance, ease = 1) {
                let direction = "in";
                OverwriteOrbit(orbit);

                switch (ease) {
                    case 1:
                        ease = "linear";
                        break;
                    case 2:
                        ease = "sine";
                        break;
                    case 3:
                        ease = "sine";
                        direction = "out";
                        break;
                    case 4:
                        ease = "sine";
                        direction = "in out";
                        break;
                }

                for (let currentTime = time; currentTime < time + length; currentTime = currentTime + 20) {
                    if (GetTimeline(currentTime, orbit) != false) {
                        orbits[orbit] = GetTimeline(currentTime, orbit);
                    }

                    orbits[orbit][4] = tween.tweenValue(ease, direction, startDistance, endDistance, (currentTime - time) / length);
                    OverwriteTimeline(currentTime, orbit);
                }

                if (GetTimeline(time + length, orbit) != false) {
                    orbits[orbit] = GetTimeline(time + length, orbit);
                }

                orbits[orbit][4] = endDistance;
                OverwriteTimeline(time + length, orbit);
            }

            try {
                eval(document.querySelector('.main .container > textarea[name="script"]').value.replaceAll(".,", "undefined,"));
                
                Object.keys(timeline).forEach((key) => {
                    fumen.push(timeline[key]);
                });

                fumen.sort((inp, com) => {
                    return inp[0] - com[0];
                });

                console.log(timeline);

                fumen.splice(0, 0, orbitNumber);
                document.querySelector('.main .content > textarea[name="result"]').value = JSON.stringify(fumen);
            } catch (error) {
                document.querySelector('.main .content > textarea[name="result"]').value = error.message;
            } finally {
                document.querySelector('.main .content > textarea[name="result"]').style.height = "1px";
                document.querySelector('.main .content > textarea[name="result"]').style.height = document.querySelector('.main .content > textarea[name="result"]').scrollHeight + 3 + "px";
                let script = document.querySelector('.main .container > textarea[name="script"]').value;
                script = script.substring(0, document.querySelector('.main .container > textarea[name="script"]').selectionStart);
                script = script.substring(0, script.lastIndexOf(";"));
                script = script.replaceAll(".,", "undefined,");
                eval(script);
                
                document.querySelector(".main .container > .details").innerHTML = `
                    BPM = ${bpm}<br>
                    Current time = ${Math.floor(time)}
                `;

                document.querySelector(".main .page").style.height = "";
            }
        }
    </script>
</html>